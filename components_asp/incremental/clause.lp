% #program correct_inv2(n,np1,pos1,np2,pos2).
% correct(n,Pred,Vars,pos1):-pred_vars_no(np1,Pred,Vars).
% correct(n,Pred,Vars,pos2):-pred_vars_no(np2,Pred,Vars).

% % #show correct/4.


% :- all_subst(St), #count{Pred,Vars,Pos: output(Pred,Vars,Pos),correct(n,Pred,Vars0,Pos),subst(Vars0,Vars,St)}=2.

% #program correct_inv3(n,np1,pos1,np2,pos2,np3,pos3).
% correct(n,Pred,Vars,pos1):-pred_vars_no(np1,Pred,Vars).
% correct(n,Pred,Vars,pos2):-pred_vars_no(np2,Pred,Vars).
% correct(n,Pred,Vars,pos3):-pred_vars_no(np3,Pred,Vars).

% % #show correct/4.


% :- all_subst(St), #count{Pred,Vars,Pos: output(Pred,Vars,Pos),correct(n,Pred,Vars0,Pos),subst(Vars0,Vars,St)}=3.

% opt: this general implementation is not as efficient as the specific ones (which can be generated by the generator), but since our performance is ok, we prefer the general one now.
#program correct_inv(n,num).
#external correct_lit(n,Np,Pos):pred_vars_no(Np,_,_),pos(Pos).
correct(n,Pred,Vars,Pos):-correct_lit(n,Np,Pos),pred_vars_no(Np,Pred,Vars).
to_var_in_n(n,Var):-correct(n,_,Vars,_),var_in(Var,Vars),to_type(Type),var_type(Var,Type).

to_more_n(n):- to_var_in_n(n,Var1),to_var_in_n(n,Var2),Var1<Var2.
valid_subst(n,St):-all_subst(St),not to_more_n(n).
valid_subst(n,St):-all_subst(St),to_more_n(n),not to_subst(St).

:- valid_subst(n,St), #count{Atom,Pos: output_no(Atom,Pos),correct_lit(n,Np,Pos),atom_subst(Np,Atom,St)}=num.

#program correct_inv_exi(n,num,exinum).
#external correct_lit(n,Np,Pos):pred_vars_no(Np,_,_),pos(Pos).
#external exi(n,Var):var_type(Var,_).
correct(n,Pred,Vars,Pos):-correct_lit(n,Np,Pos),pred_vars_no(Np,Pred,Vars).
to_var_in_n(n,Var):-correct(n,_,Vars,_),var_in(Var,Vars),to_type(Type),var_type(Var,Type).

to_more_n(n):- to_var_in_n(n,Var1),to_var_in_n(n,Var2),Var1<Var2.
valid_subst(n,St):-all_subst(St),not to_more_n(n).
valid_subst(n,St):-all_subst(St),to_more_n(n),not to_subst(St).

:- valid_subst(n,St), #count{Atom,Pos: output_no(Atom,Pos),correct_lit(n,Np,Pos),atom_subst(Np,Atom,St)}=num, #count{Var:exists(Var),exi(n,Var)}=exinum.


% #program correct_inv1_exi(n,np1,pos1,var). %TODO: more vars
% % inv_exist(n,var).
% correct(n,Pred,Vars,pos1):-pred_vars_no(np1,Pred,Vars).


% % debug_exists(n,Var):- inv_exist(n,Var).
% % #show debug_exists/2.

% :- all_subst(St), #count{Pred,Vars,Pos: output(Pred,Vars,Pos),correct(n,Pred,Vars0,Pos),subst(Vars0,Vars,St)}=1,exists(V), var_subst(St,var,V).

% #program correct_inv2_exi(n,np1,pos1,np2,pos2,var).
% % inv_exist(n,var).
% correct(n,Pred,Vars,pos1):-pred_vars_no(np1,Pred,Vars).
% correct(n,Pred,Vars,pos2):-pred_vars_no(np2,Pred,Vars).


% :- all_subst(St), #count{Pred,Vars,Pos: output(Pred,Vars,Pos),correct(n,Pred,Vars0,Pos),subst(Vars0,Vars,St)}=2,exists(V), var_subst(St,var,V).

